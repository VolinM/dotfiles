{"cmd": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport scipy.integrate as integrate\n\n# physical constants\nhbar = 1\nm = 1\n\n# probelm parameters\na = -10 # begining of the potential well\nb =  10 # end of the motential well\n\nenergy_levels = 10\n\ndx = 0.1\n\nxs = np.arange(a, b+dx, dx, dtype=np.float64)\nnx = xs.shape[0]\n\n# potential\ndef potential(x):\n    return 0\npotential = np.vectorize(potential)\n\n                             ############################\n############################## finite difference method #########################\n                             ############################\n\n# kinetic energy\nones = np.ones_like(xs)\nT = np.diag(ones[:-1],1) - 2*np.diag(ones) + np.diag(ones[:-1],-1)\nT *= -(hbar**2/(2*dx**2))\n\n# potential energy\nV = potential(xs)\nV = np.diag(V)\n\n# hamiltonian\nH = T + V\n\n# eigenvalue equation\nval, vec = np.linalg.eig(H)\nvec = vec[:, val != 0]\nval = val[val != 0]\nz = np.argsort(val)\nz = z[:energy_levels]\n\n# normalizing the energies\nenergies = np.round(val[z]/val[z][0])\nprint(energies)\n\n# normalizing the wavefunctions\nfor i in range(energy_levels):\n    v = vec[:,z[i]]\n    norm = integrate.simpson(v**2,xs)\n    v /= np.sqrt(norm)\n    vec[:,z[i]] = v\n\n\n#>\n# PLOT\n\nfig, ax = plt.subplots(nrows=energy_levels//2, ncols=2)\n\nfor i,row in enumerate(ax):\n    for j,col in enumerate(row):\n        n = 2*i + j\n        col.plot(xs,(vec[:,z[n]])**2, lw=1, color='C{}'.format(n))\n        col.set_title('$E_{}$'.format(str(n+1)))\n        col.set_xlabel('$x$')\n        col.set_ylabel('$|\\psi|^2$')\n        col.set_xlim([a*1.1, b*1.1])\n\nplt.subplots_adjust(left=0.1, bottom=0.1, right=0.9,top=0.9, wspace=0.3, hspace=1)\nplt.savefig('potenial_well.png')\n\n#>\n# EXPORTING THE RESULTS\n\nti_wf = {str(n+1):vec[:,z[n]] for n in range(energy_levels)}\nti_wf['xs'] = xs\nnp.save('ti_well.npy', ti_wf, allow_pickle=True)\n\n\n", "cmd_opts": " --cell_id=NONE -s", "import_complete": 1, "terminal": "nvimterm"}